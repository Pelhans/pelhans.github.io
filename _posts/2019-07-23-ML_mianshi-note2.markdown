---
layout:     post
title:      "NLP 手册"
subtitle:   "逻辑回归"
date:       2019-07-23 00:15:18
author:     "Pelhans"
header-img: "img/kg_bg.jpg"
header-mask: 0.3 
catalog:    true
tags:
    - PRML
---


* TOC
{:toc}

# Logistic 回归

## 问题的定义

逻辑回归假设数据服从伯努利分布
$ P(y|X, \theta) $ ，在已知变量 x 的情况下，y 服从伯努利分布，通过 极大似然估计的方法，运用梯度下降或者拟牛顿法等最优化方法来求解参数，以达到二分类的目的。

现在我们假设模型的输出为 $h_{\theta}(x)$，参数用 $\theta$ 表示。 则：

$$ h_{\theta}(x) = g(\theta^{T}x) = \frac{1}{1+e^{-\theta^{T}x}} $$

$$ g(z) = \frac{1}{1+e^{-z}} $$

其中 $g(z)$ 被称为 logistic 函数或 Sigmoid 函数。 长下图这样：

![](/img/in-post/ml_mianshi/logistic_sigmoid.png)

该函数的特性是 当 z 趋于正无穷时 趋近于1，z 趋于负无穷时 接近 0。这样可以保证作为二分类问题，输出值会落在 0-1 之间。需要提的是，其他在 0-1 范围内光滑递增的函数也能被使用，但对于二分类问题来说， logistic 函数是可以经过推导得到的更为自然的选择。

## 参数的求解

因为我们假设 y 服从伯努利分布，因此：

$$ P(y=1 | x; \theta) = h_{\theta}(x) $$

$$ P(y=0 | x; \theta) = 1 - h_{\theta}(x) $$

用一个式子表达就是：

$$ p(y | x; \theta) = (h_{\theta}(x) )^{y}( 1 - h_{\theta}(x)  )^{1-y} $$

假设数据遵从独立同分布，则似然函数可以写为：

$$ 
\begin{aligned}
L(\theta) & = p(\overrightarrow{y} | X; \theta ) \\
 & = \prod_{i=1}^{n}p(y^{(i)}| x^{(i)}; \theta ) \\
 & = \prod_{i=1}^{n}(h_{\theta}(x^{(i)}))^{y^{(i)}}(1 - h_{\theta}(x^{(i)}))^{1-y^{(i)}}
\end{aligned}
$$

把似然函数变为对数形式方便最大化：

$$
\begin{aligned}
l(\theta) & = \log L(\theta) \\
& = \sum_{i=1}^{n}y^{(i)}\log h(x^{i}) + (1-y^{(i)})\log(1-h(x^{i}))
\end{aligned}
$$

### 梯度下降法

比较套路的方法，首先我们知道梯度法更新参数的公式为：

$$ \theta = \theta + \alpha\nabla_{\theta}l(\theta) $$

所以我们只要求 对数似然函数对参数的导数即可：

$$
\begin{aligned}
\frac{\partial }{\partial \theta_{j}}l(\theta) & = (y\frac{1}{g(\theta^{T})} -(1-y)\frac{1}{1-g(\theta^{T}x)} )\frac{\partial }{\partial \theta_{j}}g(\theta^{T}x) \\
& = (y\frac{1}{g(\theta^{T})} -(1-y)\frac{1}{1-g(\theta^{T}x)})g(\theta^{T}x)(1-g(\theta^{T}x))\frac{\partial }{\partial \theta_{j}}\theta^{T}x \\
& = (y(1-g(\theta^{T}x)) -(1-y)g(\theta^{T}x) )x_{j} \\
& = (y-h_{\theta}(x))x_{j}
\end{aligned}
$$

带入参数的更新公式可得：

$$ \theta_{j} = \theta_{j} + \alpha(y^{(i)} - h_{\theta}(x^{(i)}) )x_{j}^{(i)} $$

和前面最小二乘法得到的更新公式是一样的。

## 问题汇总

### LR 的归一化问题

什么事归一化，什么情况可以不归一化，什么情况必须归一化，常用的归一化方法有哪些

涉及到不同指标的变量时，这些变量通常有不同的量纲和单位，这样的情况会影响到数据分析的结果，为了消除这种影响，需要进行数据标准化处理(标准化是将数据按比例缩放到一个小的特定区间)。其中最典型的就是数据的归一化处理(归到 0-1 之间)。


有些模型在各个维度进行不均匀伸缩后，最优解与原来不等价，例如SVM，对于这样的模型，除非本来各维数据的分布范围就比较接近，否则必须进行标准化，以免模型参数被分布范围较大或较小的数据主导。   有些模型在各个维度进行不均匀伸缩后，最优解与原来等价，例如logistic 回归，对于这样的模型，是否标准化理论上不会改变最优解。但是，由于实际求解往往使用迭代算法，如果目标函数的形状太“扁”，迭代算法可能收敛得很慢(走很多弯路)甚至不收敛（模型结果不精确）。所以对于具有伸缩不变性的模型，最好也进行数据标准化。

常用的归一化方法有：

* 最大最小标准化：又称离差标准化，将结果映射到 0-1，转换函数为：

$$ x^{'} = \frac{x - \min(x)}{\max(x) - \min(x)} $$

适用于数值比较集中的时候，缺点是  max 和 min 不稳定的话会导致归一化结果不稳定，从而影响后续结果。实际中可以用 经验值 代替 max 和 min。

* Z-score标准化方法

对应公式为：

$$ x^{'} = \frac{x-\mu}{\sigma} $$

其中 $\mu$ 为所有样本数据的均值， $\sigma$ 为所有样本数据的标准差。

本方法要求原始数据的分布可以近似为高斯分布，否则归一化的效果会变得很糟糕。

适用于 在分类、聚类算法中，需要使用距离来度量相似性的时候、或者使用PCA技术进行降维等场景中。

* 非线性归一化

适用于在数据分化比较大的场景，有些数值很大，有些很小。通过一些数学函数，将原始值进行映射。如 log 、正切、反正切、L2 范数归一化(特征向量中每个元素都除以向量的L2范数)等。

## 为什么逻辑回归要用极大似然法来进行参数估计而不是最小二乘法？

可以证明逻辑回归的最小二乘法的代价函数不是关于分布参数θ的凸函数(证明凸函数需要证明函数的二阶导数为半负定矩阵)，求解过程中，会得到局部最优，不容易求解全局最优θ。

从分类和回归的角度说，因为逻辑回归不是一种回归，而是一种分类算法。而逻辑回归的假设函数是属于指数分布族，且逻辑回归的样本给予满足伯努利分布而进行训练的。最大似然估计的出发点就是使得当前样本发生的可能性最大化，反向支持逻辑回归样本满足伯努利分布。而最小二乘法只是让预测值和观测值更拟合，而最大似然估计是保证计算出的特征值发生的概率正确率最大化，最大似然更满足逻辑回归是一种分类器。

## 逻辑回归是线性模型还是非线性模型 ？

从输出来看，逻辑回归明显是非线性模型(因为 sigmoid 函数)，但它的决策面却是超平面而不是曲面。

$$ h(z) = \frac{1}{1 + e^{-z}} $$

$$ z = g(x) = \theta x$$

当阈值为0.5， $$ z \geq 0 时，分类到 1，反之则为 0。因此 这里的 g(x) 是实际的决策面，它是线性的。sigmoid 函数只是对输出进行映射，未影响最终决策。因此它是线性模型。但当 g(x) 是非线性的时候，那决策面显然是非线性的。因此在使用逻辑回归之前，需要了解原始数据是否为线性，而后进行合适的变换或处理。

## LR作为一个线性模型，如何拟合非线性情况？

特征方面可以用 离散化、交叉组合、 lr + gbdt 增大有效特征的维度等方式。据covar定理，维度越高则线性可分的概率越高，实际上目的和核技巧类似，把问题转化到高维空间上去以找到某一个决策的超平面，实现原始问题的线性可分。

模型方面 可以引入核方法，映射到高维空间解决问题。 综上所述，核心思想是对特征和模型进行处理，将低维空间的非线性问题映射到高维空间作为线性问题解决。

## 逻辑回归怎么实现多分类 ？ (该问题可以适配到其他二分类问题)

分为算法层面和数据层面. 在数据层面,最经典的拆分策略有三种: 一对一, 一对多, 多对多. 例如有 A, B, C 三个类别.

* 一对一: 不同类之间两两配对, (A, B), (B,C), (A, C). 每两个类别之间训练一个模型,最终训练三个模型做预测后,适用投票法或概率平均等方法得到最终类别.    
* 一对多:把一个类作为正类,其余作为负类, (A, 其他), (B, 其他), (C, 其他). 取模型中非 其他项概率最高的作为分类结果. 此方法比较常见,复杂度较低,效果和 一对一差不多. xgboost, lightgbm 内部采用此种实现方式.        
* 多对多: 采用若干个类作为正类, 其他的作为负类. 模型选取不同的组合 m 次, 生成m个模型然后分别预测最后根据海明距离或者欧式距离来输出最终的预测结果。

从算法层面就是将 sigmoid 改为 softmax 从而处理多分类得问题.

## 什么时候用softmax 分类, 什么时候用 sigmoid?

类别之间存在交叉得时候用 sigmoid, 互斥得话用 softmax,

[机器学习——标准化/归一化的目的、作用和场景](https://blog.csdn.net/zenghaitao0128/article/details/78361038)
